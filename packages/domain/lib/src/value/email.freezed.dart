// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'email.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$EmailAvailableFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() taken,
    required TResult Function() reserved,
    required TResult Function() banned,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? taken,
    TResult? Function()? reserved,
    TResult? Function()? banned,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? taken,
    TResult Function()? reserved,
    TResult Function()? banned,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Taken value) taken,
    required TResult Function(_Reserved value) reserved,
    required TResult Function(_Banned value) banned,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Taken value)? taken,
    TResult? Function(_Reserved value)? reserved,
    TResult? Function(_Banned value)? banned,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Taken value)? taken,
    TResult Function(_Reserved value)? reserved,
    TResult Function(_Banned value)? banned,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmailAvailableFailureCopyWith<$Res> {
  factory $EmailAvailableFailureCopyWith(EmailAvailableFailure value,
          $Res Function(EmailAvailableFailure) then) =
      _$EmailAvailableFailureCopyWithImpl<$Res, EmailAvailableFailure>;
}

/// @nodoc
class _$EmailAvailableFailureCopyWithImpl<$Res,
        $Val extends EmailAvailableFailure>
    implements $EmailAvailableFailureCopyWith<$Res> {
  _$EmailAvailableFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_TakenCopyWith<$Res> {
  factory _$$_TakenCopyWith(_$_Taken value, $Res Function(_$_Taken) then) =
      __$$_TakenCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_TakenCopyWithImpl<$Res>
    extends _$EmailAvailableFailureCopyWithImpl<$Res, _$_Taken>
    implements _$$_TakenCopyWith<$Res> {
  __$$_TakenCopyWithImpl(_$_Taken _value, $Res Function(_$_Taken) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Taken implements _Taken {
  const _$_Taken();

  @override
  String toString() {
    return 'EmailAvailableFailure.taken()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Taken);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() taken,
    required TResult Function() reserved,
    required TResult Function() banned,
  }) {
    return taken();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? taken,
    TResult? Function()? reserved,
    TResult? Function()? banned,
  }) {
    return taken?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? taken,
    TResult Function()? reserved,
    TResult Function()? banned,
    required TResult orElse(),
  }) {
    if (taken != null) {
      return taken();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Taken value) taken,
    required TResult Function(_Reserved value) reserved,
    required TResult Function(_Banned value) banned,
  }) {
    return taken(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Taken value)? taken,
    TResult? Function(_Reserved value)? reserved,
    TResult? Function(_Banned value)? banned,
  }) {
    return taken?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Taken value)? taken,
    TResult Function(_Reserved value)? reserved,
    TResult Function(_Banned value)? banned,
    required TResult orElse(),
  }) {
    if (taken != null) {
      return taken(this);
    }
    return orElse();
  }
}

abstract class _Taken implements EmailAvailableFailure {
  const factory _Taken() = _$_Taken;
}

/// @nodoc
abstract class _$$_ReservedCopyWith<$Res> {
  factory _$$_ReservedCopyWith(
          _$_Reserved value, $Res Function(_$_Reserved) then) =
      __$$_ReservedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ReservedCopyWithImpl<$Res>
    extends _$EmailAvailableFailureCopyWithImpl<$Res, _$_Reserved>
    implements _$$_ReservedCopyWith<$Res> {
  __$$_ReservedCopyWithImpl(
      _$_Reserved _value, $Res Function(_$_Reserved) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Reserved implements _Reserved {
  const _$_Reserved();

  @override
  String toString() {
    return 'EmailAvailableFailure.reserved()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Reserved);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() taken,
    required TResult Function() reserved,
    required TResult Function() banned,
  }) {
    return reserved();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? taken,
    TResult? Function()? reserved,
    TResult? Function()? banned,
  }) {
    return reserved?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? taken,
    TResult Function()? reserved,
    TResult Function()? banned,
    required TResult orElse(),
  }) {
    if (reserved != null) {
      return reserved();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Taken value) taken,
    required TResult Function(_Reserved value) reserved,
    required TResult Function(_Banned value) banned,
  }) {
    return reserved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Taken value)? taken,
    TResult? Function(_Reserved value)? reserved,
    TResult? Function(_Banned value)? banned,
  }) {
    return reserved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Taken value)? taken,
    TResult Function(_Reserved value)? reserved,
    TResult Function(_Banned value)? banned,
    required TResult orElse(),
  }) {
    if (reserved != null) {
      return reserved(this);
    }
    return orElse();
  }
}

abstract class _Reserved implements EmailAvailableFailure {
  const factory _Reserved() = _$_Reserved;
}

/// @nodoc
abstract class _$$_BannedCopyWith<$Res> {
  factory _$$_BannedCopyWith(_$_Banned value, $Res Function(_$_Banned) then) =
      __$$_BannedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_BannedCopyWithImpl<$Res>
    extends _$EmailAvailableFailureCopyWithImpl<$Res, _$_Banned>
    implements _$$_BannedCopyWith<$Res> {
  __$$_BannedCopyWithImpl(_$_Banned _value, $Res Function(_$_Banned) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Banned implements _Banned {
  const _$_Banned();

  @override
  String toString() {
    return 'EmailAvailableFailure.banned()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Banned);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() taken,
    required TResult Function() reserved,
    required TResult Function() banned,
  }) {
    return banned();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? taken,
    TResult? Function()? reserved,
    TResult? Function()? banned,
  }) {
    return banned?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? taken,
    TResult Function()? reserved,
    TResult Function()? banned,
    required TResult orElse(),
  }) {
    if (banned != null) {
      return banned();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Taken value) taken,
    required TResult Function(_Reserved value) reserved,
    required TResult Function(_Banned value) banned,
  }) {
    return banned(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Taken value)? taken,
    TResult? Function(_Reserved value)? reserved,
    TResult? Function(_Banned value)? banned,
  }) {
    return banned?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Taken value)? taken,
    TResult Function(_Reserved value)? reserved,
    TResult Function(_Banned value)? banned,
    required TResult orElse(),
  }) {
    if (banned != null) {
      return banned(this);
    }
    return orElse();
  }
}

abstract class _Banned implements EmailAvailableFailure {
  const factory _Banned() = _$_Banned;
}

/// @nodoc
mixin _$EmailFormatFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalid,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Invalid value) invalid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Invalid value)? invalid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Invalid value)? invalid,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmailFormatFailureCopyWith<$Res> {
  factory $EmailFormatFailureCopyWith(
          EmailFormatFailure value, $Res Function(EmailFormatFailure) then) =
      _$EmailFormatFailureCopyWithImpl<$Res, EmailFormatFailure>;
}

/// @nodoc
class _$EmailFormatFailureCopyWithImpl<$Res, $Val extends EmailFormatFailure>
    implements $EmailFormatFailureCopyWith<$Res> {
  _$EmailFormatFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_InvalidCopyWith<$Res> {
  factory _$$_InvalidCopyWith(
          _$_Invalid value, $Res Function(_$_Invalid) then) =
      __$$_InvalidCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InvalidCopyWithImpl<$Res>
    extends _$EmailFormatFailureCopyWithImpl<$Res, _$_Invalid>
    implements _$$_InvalidCopyWith<$Res> {
  __$$_InvalidCopyWithImpl(_$_Invalid _value, $Res Function(_$_Invalid) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Invalid implements _Invalid {
  const _$_Invalid();

  @override
  String toString() {
    return 'EmailFormatFailure.invalid()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Invalid);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalid,
  }) {
    return invalid();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalid,
  }) {
    return invalid?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalid,
    required TResult orElse(),
  }) {
    if (invalid != null) {
      return invalid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Invalid value) invalid,
  }) {
    return invalid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Invalid value)? invalid,
  }) {
    return invalid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Invalid value)? invalid,
    required TResult orElse(),
  }) {
    if (invalid != null) {
      return invalid(this);
    }
    return orElse();
  }
}

abstract class _Invalid implements EmailFormatFailure {
  const factory _Invalid() = _$_Invalid;
}

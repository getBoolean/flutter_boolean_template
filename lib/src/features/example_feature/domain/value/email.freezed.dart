// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'email.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$EmailAvailableFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() taken,
    required TResult Function() reserved,
    required TResult Function() banned,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? taken,
    TResult? Function()? reserved,
    TResult? Function()? banned,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? taken,
    TResult Function()? reserved,
    TResult Function()? banned,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Taken value) taken,
    required TResult Function(_Reserved value) reserved,
    required TResult Function(_Banned value) banned,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Taken value)? taken,
    TResult? Function(_Reserved value)? reserved,
    TResult? Function(_Banned value)? banned,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Taken value)? taken,
    TResult Function(_Reserved value)? reserved,
    TResult Function(_Banned value)? banned,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmailAvailableFailureCopyWith<$Res> {
  factory $EmailAvailableFailureCopyWith(EmailAvailableFailure value,
          $Res Function(EmailAvailableFailure) then) =
      _$EmailAvailableFailureCopyWithImpl<$Res, EmailAvailableFailure>;
}

/// @nodoc
class _$EmailAvailableFailureCopyWithImpl<$Res,
        $Val extends EmailAvailableFailure>
    implements $EmailAvailableFailureCopyWith<$Res> {
  _$EmailAvailableFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$TakenImplCopyWith<$Res> {
  factory _$$TakenImplCopyWith(
          _$TakenImpl value, $Res Function(_$TakenImpl) then) =
      __$$TakenImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TakenImplCopyWithImpl<$Res>
    extends _$EmailAvailableFailureCopyWithImpl<$Res, _$TakenImpl>
    implements _$$TakenImplCopyWith<$Res> {
  __$$TakenImplCopyWithImpl(
      _$TakenImpl _value, $Res Function(_$TakenImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TakenImpl implements _Taken {
  const _$TakenImpl();

  @override
  String toString() {
    return 'EmailAvailableFailure.taken()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TakenImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() taken,
    required TResult Function() reserved,
    required TResult Function() banned,
  }) {
    return taken();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? taken,
    TResult? Function()? reserved,
    TResult? Function()? banned,
  }) {
    return taken?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? taken,
    TResult Function()? reserved,
    TResult Function()? banned,
    required TResult orElse(),
  }) {
    if (taken != null) {
      return taken();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Taken value) taken,
    required TResult Function(_Reserved value) reserved,
    required TResult Function(_Banned value) banned,
  }) {
    return taken(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Taken value)? taken,
    TResult? Function(_Reserved value)? reserved,
    TResult? Function(_Banned value)? banned,
  }) {
    return taken?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Taken value)? taken,
    TResult Function(_Reserved value)? reserved,
    TResult Function(_Banned value)? banned,
    required TResult orElse(),
  }) {
    if (taken != null) {
      return taken(this);
    }
    return orElse();
  }
}

abstract class _Taken implements EmailAvailableFailure {
  const factory _Taken() = _$TakenImpl;
}

/// @nodoc
abstract class _$$ReservedImplCopyWith<$Res> {
  factory _$$ReservedImplCopyWith(
          _$ReservedImpl value, $Res Function(_$ReservedImpl) then) =
      __$$ReservedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ReservedImplCopyWithImpl<$Res>
    extends _$EmailAvailableFailureCopyWithImpl<$Res, _$ReservedImpl>
    implements _$$ReservedImplCopyWith<$Res> {
  __$$ReservedImplCopyWithImpl(
      _$ReservedImpl _value, $Res Function(_$ReservedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ReservedImpl implements _Reserved {
  const _$ReservedImpl();

  @override
  String toString() {
    return 'EmailAvailableFailure.reserved()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ReservedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() taken,
    required TResult Function() reserved,
    required TResult Function() banned,
  }) {
    return reserved();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? taken,
    TResult? Function()? reserved,
    TResult? Function()? banned,
  }) {
    return reserved?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? taken,
    TResult Function()? reserved,
    TResult Function()? banned,
    required TResult orElse(),
  }) {
    if (reserved != null) {
      return reserved();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Taken value) taken,
    required TResult Function(_Reserved value) reserved,
    required TResult Function(_Banned value) banned,
  }) {
    return reserved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Taken value)? taken,
    TResult? Function(_Reserved value)? reserved,
    TResult? Function(_Banned value)? banned,
  }) {
    return reserved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Taken value)? taken,
    TResult Function(_Reserved value)? reserved,
    TResult Function(_Banned value)? banned,
    required TResult orElse(),
  }) {
    if (reserved != null) {
      return reserved(this);
    }
    return orElse();
  }
}

abstract class _Reserved implements EmailAvailableFailure {
  const factory _Reserved() = _$ReservedImpl;
}

/// @nodoc
abstract class _$$BannedImplCopyWith<$Res> {
  factory _$$BannedImplCopyWith(
          _$BannedImpl value, $Res Function(_$BannedImpl) then) =
      __$$BannedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BannedImplCopyWithImpl<$Res>
    extends _$EmailAvailableFailureCopyWithImpl<$Res, _$BannedImpl>
    implements _$$BannedImplCopyWith<$Res> {
  __$$BannedImplCopyWithImpl(
      _$BannedImpl _value, $Res Function(_$BannedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BannedImpl implements _Banned {
  const _$BannedImpl();

  @override
  String toString() {
    return 'EmailAvailableFailure.banned()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BannedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() taken,
    required TResult Function() reserved,
    required TResult Function() banned,
  }) {
    return banned();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? taken,
    TResult? Function()? reserved,
    TResult? Function()? banned,
  }) {
    return banned?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? taken,
    TResult Function()? reserved,
    TResult Function()? banned,
    required TResult orElse(),
  }) {
    if (banned != null) {
      return banned();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Taken value) taken,
    required TResult Function(_Reserved value) reserved,
    required TResult Function(_Banned value) banned,
  }) {
    return banned(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Taken value)? taken,
    TResult? Function(_Reserved value)? reserved,
    TResult? Function(_Banned value)? banned,
  }) {
    return banned?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Taken value)? taken,
    TResult Function(_Reserved value)? reserved,
    TResult Function(_Banned value)? banned,
    required TResult orElse(),
  }) {
    if (banned != null) {
      return banned(this);
    }
    return orElse();
  }
}

abstract class _Banned implements EmailAvailableFailure {
  const factory _Banned() = _$BannedImpl;
}

/// @nodoc
mixin _$EmailFormatFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalid,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Invalid value) invalid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Invalid value)? invalid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Invalid value)? invalid,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmailFormatFailureCopyWith<$Res> {
  factory $EmailFormatFailureCopyWith(
          EmailFormatFailure value, $Res Function(EmailFormatFailure) then) =
      _$EmailFormatFailureCopyWithImpl<$Res, EmailFormatFailure>;
}

/// @nodoc
class _$EmailFormatFailureCopyWithImpl<$Res, $Val extends EmailFormatFailure>
    implements $EmailFormatFailureCopyWith<$Res> {
  _$EmailFormatFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InvalidImplCopyWith<$Res> {
  factory _$$InvalidImplCopyWith(
          _$InvalidImpl value, $Res Function(_$InvalidImpl) then) =
      __$$InvalidImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InvalidImplCopyWithImpl<$Res>
    extends _$EmailFormatFailureCopyWithImpl<$Res, _$InvalidImpl>
    implements _$$InvalidImplCopyWith<$Res> {
  __$$InvalidImplCopyWithImpl(
      _$InvalidImpl _value, $Res Function(_$InvalidImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InvalidImpl implements _Invalid {
  const _$InvalidImpl();

  @override
  String toString() {
    return 'EmailFormatFailure.invalid()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InvalidImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalid,
  }) {
    return invalid();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalid,
  }) {
    return invalid?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalid,
    required TResult orElse(),
  }) {
    if (invalid != null) {
      return invalid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Invalid value) invalid,
  }) {
    return invalid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Invalid value)? invalid,
  }) {
    return invalid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Invalid value)? invalid,
    required TResult orElse(),
  }) {
    if (invalid != null) {
      return invalid(this);
    }
    return orElse();
  }
}

abstract class _Invalid implements EmailFormatFailure {
  const factory _Invalid() = _$InvalidImpl;
}
